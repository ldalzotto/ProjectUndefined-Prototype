{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome This repository is the source code of a proof of concept of a Unity game. ProjectUndefined is a prototype of a top down 3D shooter. The Player can stop time whenever he wants and cast skill to progress trough levels. This project was made to challenge my knowledge acquired with the unity engine. This project emphasis my will of building custom solutions for features that I found too limiting in the engine : animation system, surface shader, prefabs. I am satisfied with the solutions that I brought, but the code is not very comprehensive. This repository contains source code only, there is no asset files. I decided to strip assets from git history as they were taking space for nothing. The whole unity project with assets is available here . Some features are more detailed here , these are some that I could reuse in future projects. Try it A playable demo is here . Controls Controls are always displayed in-game and are dynamic depending of the current state. Features The application features (links redirect to source code implementation) : Custom Player controller Skill management for Player and AI . Firing projectiles. Deflecting projectiles when an incoming projectile is on range and health is low. Teleporting to a location in range. AI Behavior driven by fsm. Only one AI Behavior is implemented for soldier. Interactive objects entirely defined via scriptable object that interact with the environment. Health globe interactive objects that give health on trigger. Player and AI are also InteractiveObjects. 3D Physics shape that takes into account obstacle occlusion to trigger game logic like AI line of sight for example. Start/Stop time. Custom Animation system based on the Playable API. Custom toon shader integrated with the URP","title":"Welcome"},{"location":"#welcome","text":"This repository is the source code of a proof of concept of a Unity game. ProjectUndefined is a prototype of a top down 3D shooter. The Player can stop time whenever he wants and cast skill to progress trough levels. This project was made to challenge my knowledge acquired with the unity engine. This project emphasis my will of building custom solutions for features that I found too limiting in the engine : animation system, surface shader, prefabs. I am satisfied with the solutions that I brought, but the code is not very comprehensive. This repository contains source code only, there is no asset files. I decided to strip assets from git history as they were taking space for nothing. The whole unity project with assets is available here . Some features are more detailed here , these are some that I could reuse in future projects.","title":"Welcome"},{"location":"#try-it","text":"A playable demo is here .","title":"Try it"},{"location":"#controls","text":"Controls are always displayed in-game and are dynamic depending of the current state.","title":"Controls"},{"location":"#features","text":"The application features (links redirect to source code implementation) : Custom Player controller Skill management for Player and AI . Firing projectiles. Deflecting projectiles when an incoming projectile is on range and health is low. Teleporting to a location in range. AI Behavior driven by fsm. Only one AI Behavior is implemented for soldier. Interactive objects entirely defined via scriptable object that interact with the environment. Health globe interactive objects that give health on trigger. Player and AI are also InteractiveObjects. 3D Physics shape that takes into account obstacle occlusion to trigger game logic like AI line of sight for example. Start/Stop time. Custom Animation system based on the Playable API. Custom toon shader integrated with the URP","title":"Features"},{"location":"animator_playable/","text":"The animator playable simulates the unity built-in animator controller state machines. It is a system a system that play layered animations via the playable api. It's role is to calculate and push blending factors to the playable api. Blending factor calculation depends of the type of the animation layer. The animator playable supports : Sequenced animation with blending between every clip depending of the evaluated time. 1D Blended animation that play multiple animation in parallel weighted by a single float parameter. 2D blended animation that play multiple animation in parallel weighted by two float parameters. Animation layers Animation layers are object that play one or more animation clip. Layers are ordered, meaning that the animation of the layer 2 will override results of the layer 1. Sequenced animation layer Sequenced animation layers are animation clips that are played one after another. Transition between one clip to another can be blended in function of the internal clock of the layer. Transition blending is defined by a begin and end time and is always linear. The sequenced animations can be repeated. 1D Blended animation layer The blended animation layer is the same as the sequenced animation layer. However, it is not the elapsed time that control the weight of animation clips, it's an input variable associated to the layer called \"weight evaluation\". The weight evaluation is clamped between 0 and 1 and every clip has a blending function that return the desired weight of the animation based on the weight evaluation. It is up to the consumer to send the desired weight evaluation value. 2D Blended animation layer Use the same logic as the 1D blended animation layer but the weight evaluation variable are 2 floats. Instead of having blending functions for every clip, they have a 2D position clamped between -1 and 1. Animation clip weights are calculated by using the gradient band interpolation (see Automated Semi\u2010Procedural Animation for Character Locomotion @ #6.3 Gradient Band Interpolation, page 58)","title":"Animator playable"},{"location":"animator_playable/#animation-layers","text":"Animation layers are object that play one or more animation clip. Layers are ordered, meaning that the animation of the layer 2 will override results of the layer 1.","title":"Animation layers"},{"location":"animator_playable/#sequenced-animation-layer","text":"Sequenced animation layers are animation clips that are played one after another. Transition between one clip to another can be blended in function of the internal clock of the layer. Transition blending is defined by a begin and end time and is always linear. The sequenced animations can be repeated.","title":"Sequenced animation layer"},{"location":"animator_playable/#1d-blended-animation-layer","text":"The blended animation layer is the same as the sequenced animation layer. However, it is not the elapsed time that control the weight of animation clips, it's an input variable associated to the layer called \"weight evaluation\". The weight evaluation is clamped between 0 and 1 and every clip has a blending function that return the desired weight of the animation based on the weight evaluation. It is up to the consumer to send the desired weight evaluation value.","title":"1D Blended animation layer"},{"location":"animator_playable/#2d-blended-animation-layer","text":"Use the same logic as the 1D blended animation layer but the weight evaluation variable are 2 floats. Instead of having blending functions for every clip, they have a 2D position clamped between -1 and 1. Animation clip weights are calculated by using the gradient band interpolation (see Automated Semi\u2010Procedural Animation for Character Locomotion @ #6.3 Gradient Band Interpolation, page 58)","title":"2D Blended animation layer"},{"location":"range_intersection/","text":"The range intersection system is the system that allows the enemies to spot the player when he is in sight. The system takes into account obstacles, meaning that the range will be occluded by it. Range object The range object is what defines the range shape which will be used for intersection test. The range object is composed of two shapes. Intersection shape: The intersection shape is the geometry that will be used by the intersection calculation to precisely tell if one shape is contained into another. Trigger shape: The trigger shape acts as a filter to avoid calculating precise intersection against all interactive object. The trigger shape is a Trigger component that will register other interactive objects when a trigger event if fired. The goal is to increase efficiency by not calculating precise intersection when the interactive object is far away. The intersection shape must be a shape that how to calculate if a point is inside or not. The range object keeps tracks of obstacle objects that are inside the trigger shape. Visibility probe Visibility probes are points that defines the visibility points of an interactive object. It is against these points that the intersection calculation is performed against. This method has been preferred over 3D shape intersection because I wasn't aware of sat algorithm. And the sat algorithm is probably cheaper than probe checking against a 3D geometry. Obstacle object Obstacle objects are objects that occlude the range object. When a range object is near an obstacle, occlusion frustums are projected from the point of view of the range object. These frustums will be excluded during the intersection calculation. This means that if another range object is inside the intersection shape but within an occlusion frustum, then the intersection doesn't happen. Data model Intersection calculation A single intersection calculation consists of checking if any point of the visibility probe is inside the range object considering occlusion frustums. The calculation is divide in two steps, the occlusion frustum calculations and the visibility probe test. Occlusion frustum calculation For every obstacle objects that are inside the trigger shape of the range object, occlusion frustums are projected from the origin of the range object. For now, occlusion frustums are generated from quad faces only. Points of the quad are expanded in the direction defined by the origin point by a distance defined in the visibility probe structure. To improve the efficiency of frustum calculations, there are some rules that avoid frustum recalculations : If the range object has not moved the last frame If the obstacle object has moved -> do frustum calculations for this specific obstacle If the range object has moved the last frame -> do frustum calculations for all obstacles relative to the range object Visibility probe test The visibility probe test calculates if any of the probe points are contained within the range object's intersection shape. If at least one visibilivisibility probe is inside the intersection shape and not occluded by frustum, then there is intersection. All other case result in no intersection.","title":"Range intersection"},{"location":"range_intersection/#range-object","text":"The range object is what defines the range shape which will be used for intersection test. The range object is composed of two shapes. Intersection shape: The intersection shape is the geometry that will be used by the intersection calculation to precisely tell if one shape is contained into another. Trigger shape: The trigger shape acts as a filter to avoid calculating precise intersection against all interactive object. The trigger shape is a Trigger component that will register other interactive objects when a trigger event if fired. The goal is to increase efficiency by not calculating precise intersection when the interactive object is far away. The intersection shape must be a shape that how to calculate if a point is inside or not. The range object keeps tracks of obstacle objects that are inside the trigger shape.","title":"Range object"},{"location":"range_intersection/#visibility-probe","text":"Visibility probes are points that defines the visibility points of an interactive object. It is against these points that the intersection calculation is performed against. This method has been preferred over 3D shape intersection because I wasn't aware of sat algorithm. And the sat algorithm is probably cheaper than probe checking against a 3D geometry.","title":"Visibility probe"},{"location":"range_intersection/#obstacle-object","text":"Obstacle objects are objects that occlude the range object. When a range object is near an obstacle, occlusion frustums are projected from the point of view of the range object. These frustums will be excluded during the intersection calculation. This means that if another range object is inside the intersection shape but within an occlusion frustum, then the intersection doesn't happen.","title":"Obstacle object"},{"location":"range_intersection/#data-model","text":"","title":"Data model"},{"location":"range_intersection/#intersection-calculation","text":"A single intersection calculation consists of checking if any point of the visibility probe is inside the range object considering occlusion frustums. The calculation is divide in two steps, the occlusion frustum calculations and the visibility probe test.","title":"Intersection calculation"},{"location":"range_intersection/#occlusion-frustum-calculation","text":"For every obstacle objects that are inside the trigger shape of the range object, occlusion frustums are projected from the origin of the range object. For now, occlusion frustums are generated from quad faces only. Points of the quad are expanded in the direction defined by the origin point by a distance defined in the visibility probe structure. To improve the efficiency of frustum calculations, there are some rules that avoid frustum recalculations : If the range object has not moved the last frame If the obstacle object has moved -> do frustum calculations for this specific obstacle If the range object has moved the last frame -> do frustum calculations for all obstacles relative to the range object","title":"Occlusion frustum calculation"},{"location":"range_intersection/#visibility-probe-test","text":"The visibility probe test calculates if any of the probe points are contained within the range object's intersection shape. If at least one visibilivisibility probe is inside the intersection shape and not occluded by frustum, then there is intersection. All other case result in no intersection.","title":"Visibility probe test"}]}