{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome This repository is the source code of a proof of concept of a Unity game. ProjectUndefined is a prototype of a top down 3D shooter. The Player can stop time whenever he wants and cast skill to progress trough levels. This project was made to challenge my knowledge acquired with the unity engine. This project emphasis my will of building custom solutions for features that I found too limiting in the engine : animation system, surface shader, prefabs. I am satisfied with the solutions that I brought, but the code is not very comprehensive. This repository contains source code only, there is no asset files. I decided to strip assets from git history as they were taking space for nothing. The whole unity project with assets is available here . Some features are more detailed here , these are some that I could reuse in future projects. Try it Click to see a video : A playable demo is available on itch.io or as a git release . Controls Controls are always displayed in-game and are dynamic depending of the current state. Features The application features (links redirect to source code implementation) : Custom Player controller Skill management for Player and AI . Firing projectiles. Deflecting projectiles when an incoming projectile is on range and health is low. Teleporting to a location in range. AI Behavior driven by fsm. Only one AI Behavior is implemented for soldier. Interactive objects entirely defined via scriptable object that interact with the environment. Health globe interactive objects that give health on trigger. Player and AI are also InteractiveObjects. 3D Physics shape that takes into account obstacle occlusion to trigger game logic like AI line of sight for example. Start/Stop time. Custom Animation system based on the Playable API. Custom toon shader integrated with the URP Dependencies License Feel free to steal it.","title":"Welcome"},{"location":"#welcome","text":"This repository is the source code of a proof of concept of a Unity game. ProjectUndefined is a prototype of a top down 3D shooter. The Player can stop time whenever he wants and cast skill to progress trough levels. This project was made to challenge my knowledge acquired with the unity engine. This project emphasis my will of building custom solutions for features that I found too limiting in the engine : animation system, surface shader, prefabs. I am satisfied with the solutions that I brought, but the code is not very comprehensive. This repository contains source code only, there is no asset files. I decided to strip assets from git history as they were taking space for nothing. The whole unity project with assets is available here . Some features are more detailed here , these are some that I could reuse in future projects.","title":"Welcome"},{"location":"#try-it","text":"Click to see a video : A playable demo is available on itch.io or as a git release .","title":"Try it"},{"location":"#controls","text":"Controls are always displayed in-game and are dynamic depending of the current state.","title":"Controls"},{"location":"#features","text":"The application features (links redirect to source code implementation) : Custom Player controller Skill management for Player and AI . Firing projectiles. Deflecting projectiles when an incoming projectile is on range and health is low. Teleporting to a location in range. AI Behavior driven by fsm. Only one AI Behavior is implemented for soldier. Interactive objects entirely defined via scriptable object that interact with the environment. Health globe interactive objects that give health on trigger. Player and AI are also InteractiveObjects. 3D Physics shape that takes into account obstacle occlusion to trigger game logic like AI line of sight for example. Start/Stop time. Custom Animation system based on the Playable API. Custom toon shader integrated with the URP","title":"Features"},{"location":"#dependencies","text":"","title":"Dependencies"},{"location":"#license","text":"Feel free to steal it.","title":"License"},{"location":"range_intersection/","text":"The range intersection system is the system that allows the enemies to spot the player when he is in sight. The system takes into account obstacles, meaning that the range will be occluded by it. Range object The range object is what defines the range shape which will be used for intersection test. The range object is composed of two shapes. Intersection shape: The intersection shape is the geometry that will be used by the intersection calculation to precisely tell if one shape is contained into another. Trigger shape: The trigger shape acts as a filter to avoid calculating precise intersection against all interactive object. The trigger shape is a Trigger component that will register other interactive objects when a trigger event if fired. The goal is to increase efficiency by not calculating precise intersection when the interactive object is far away. The intersection shape must be a shape that how to calculate if a point is inside or not. The range object keeps tracks of obstacle objects that are inside the trigger shape. Visibility probe Visibility probes are points that defines the visibility points of an interactive object. It is against these points that the intersection calculation is performed against. This method has been preferred over 3D shape intersection because I wasn't aware of sat algorithm. And the sat algorithm is probably cheaper than probe checking against a 3D geometry. Obstacle object Obstacle objects are objects that occlude the range object. When a range object is near an obstacle, occlusion frustums are projected from the point of view of the range object. These frustums will be excluded during the intersection calculation. This means that if another range object is inside the intersection shape but within an occlusion frustum, then the intersection doesn't happen. Data model Intersection calculation A single intersection calculation consists of checking if any point of the visibility probe is inside the range object considering occlusion frustums. The calculation is divide in two steps, the occlusion frustum calculations and the visibility probe test. Occlusion frustum calculation For every obstacle objects that are inside the trigger shape of the range object, occlusion frustums are projected from the origin of the range object. For now, occlusion frustums are generated from quad faces only. Points of the quad are expanded in the direction defined by the origin point by a distance defined in the visibility probe structure. To improve the efficiency of frustum calculations, there are some rules that avoid frustum recalculations : If the range object has not moved the last frame If the obstacle object has moved -> do frustum calculations for this specific obstacle If the range object has moved the last frame -> do frustum calculations for all obstacles relative to the range object Visibility probe test The visibility probe test calculates if any of the probe points are contained within the range object's intersection shape. If at least one visibilivisibility probe is inside the intersection shape and not occluded by frustum, then there is intersection. All other case result in no intersection.","title":"Range intersection"},{"location":"range_intersection/#range-object","text":"The range object is what defines the range shape which will be used for intersection test. The range object is composed of two shapes. Intersection shape: The intersection shape is the geometry that will be used by the intersection calculation to precisely tell if one shape is contained into another. Trigger shape: The trigger shape acts as a filter to avoid calculating precise intersection against all interactive object. The trigger shape is a Trigger component that will register other interactive objects when a trigger event if fired. The goal is to increase efficiency by not calculating precise intersection when the interactive object is far away. The intersection shape must be a shape that how to calculate if a point is inside or not. The range object keeps tracks of obstacle objects that are inside the trigger shape.","title":"Range object"},{"location":"range_intersection/#visibility-probe","text":"Visibility probes are points that defines the visibility points of an interactive object. It is against these points that the intersection calculation is performed against. This method has been preferred over 3D shape intersection because I wasn't aware of sat algorithm. And the sat algorithm is probably cheaper than probe checking against a 3D geometry.","title":"Visibility probe"},{"location":"range_intersection/#obstacle-object","text":"Obstacle objects are objects that occlude the range object. When a range object is near an obstacle, occlusion frustums are projected from the point of view of the range object. These frustums will be excluded during the intersection calculation. This means that if another range object is inside the intersection shape but within an occlusion frustum, then the intersection doesn't happen.","title":"Obstacle object"},{"location":"range_intersection/#data-model","text":"","title":"Data model"},{"location":"range_intersection/#intersection-calculation","text":"A single intersection calculation consists of checking if any point of the visibility probe is inside the range object considering occlusion frustums. The calculation is divide in two steps, the occlusion frustum calculations and the visibility probe test.","title":"Intersection calculation"},{"location":"range_intersection/#occlusion-frustum-calculation","text":"For every obstacle objects that are inside the trigger shape of the range object, occlusion frustums are projected from the origin of the range object. For now, occlusion frustums are generated from quad faces only. Points of the quad are expanded in the direction defined by the origin point by a distance defined in the visibility probe structure. To improve the efficiency of frustum calculations, there are some rules that avoid frustum recalculations : If the range object has not moved the last frame If the obstacle object has moved -> do frustum calculations for this specific obstacle If the range object has moved the last frame -> do frustum calculations for all obstacles relative to the range object","title":"Occlusion frustum calculation"},{"location":"range_intersection/#visibility-probe-test","text":"The visibility probe test calculates if any of the probe points are contained within the range object's intersection shape. If at least one visibilivisibility probe is inside the intersection shape and not occluded by frustum, then there is intersection. All other case result in no intersection.","title":"Visibility probe test"}]}